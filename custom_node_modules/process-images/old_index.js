var fs = require("fs"); // may want to do some synchronous operations
var FS = require("q-io/fs"); // may want to do some synchronous operations
var Q = require("q");
var Path = require("path");
var yargs = require("yargs");
var _ = require("underscore");
var colors = require("colors");
var spawn = require("child-process-promise").spawn;
var pkg = require("./package.json");


var options = yargs
    .usage('Process images into multiple sizes\n\nUsage: $0 -i <src folder> [options]')
    .help('help').alias('help', 'h')
    .version(pkg.version, 'version').alias('version', 'V')
    .options({
        src: {
            alias: 'i',
            description: "<folder> source images location",
            requiresArg: true,
            required: true
        },
        dest:{
        	alias: 'o',
            description: "<folder> processed images location",
            requiresArg: true,
            default: "../images_sized",
            required: false
        },
        sizes:{
        	alias: 's',
            description: "<array> JSON list of sizes to process",
            requiresArg: true,
            default: "[512,720,960,1024,1280,1440,1920]",
            required: false
        },
        baseSize: {
            alias: 'b',
            description: "<integer> standard size of source images",
            default: "1920",
            requiresArg: true,
            required: false
        },
    })
    .argv;


options.src = Path.resolve(options.src);
options.dest = Path.resolve(options.src , options.dest);
options.sizes = JSON.parse(options.sizes);
options.baseSize = parseInt(options.baseSize);

process.chdir(options.src);




var destPaths = options.sizes.map(function(size){
	return Path.resolve(
		options.dest, 
		size.toString()
	);
});

Q()
	.then(removeOldTree)
	.then(createDestinationDirs)
	.then(copyFiles)
	.then(processFolders)
	.fail(function(e){
		console.log(e);
	});

function removeOldTree(){
	console.log(">>>>>".green, "removing old tree", options.dest);
	return FS.removeTree(options.dest);
}

// create size dest dirs
function createDestinationDirs(){
	return destPaths.map(function(destPath){
		return function(){
			console.log(">>>>>".green, "createDestinationDirs", destPath);
			return FS.makeTree(destPath).then("creating done");
		};
	}).reduce(Q.when, Q());
}

function copyFiles(){
	var p = destPaths.map(function(destPath){
		return function(){
			console.log(">>>>>".green, "FS.copyTree(", Path.resolve(options.src), destPath);
			return spawn("cp", ["-r", Path.resolve(options.src) +"/", destPath]);
		};
	});
	// console.log(p);
	return p.reduce(Q.when, Q());
}

function processFolders(){
	// console.log(options.sizes)
	var p = options.sizes.map(function(size){
		return function(){
			var destPath = Path.resolve(
				options.dest, 
				size.toString()
			);
			console.log(">>>>>".greenBG, "processing", destPath);
			return processFolder(destPath, size, null);
		};
	});

	return p.reduce(Q.when, Q());
}

function processFolder(src, size, cb){

	console.log("\n\n\n\n\n\n\n",src, "\n",size,"\n\n\n\n\n\n\n")

	var deferred = Q.defer();

	
	cb = cb || function(){
		deferred.resolve();
	};

	console.log(">>".yellow,"Processing Directory: ", src);
	var list = fs.readdirSync(src);

	if (list.length === 0){
		console.log("\n\nEmpty Folder\n\n".red, src);
		cb();
		return;
	}

	// remove hidden, excluded, generated files from the list
	list = list.map(function(filename){
		if (filename.charAt(0) === "." || filename.charAt(0) === "_" || options.sizes.indexOf(filename) > -1){
			return null;
		} else {
			return filename;
		}
	});
	list = _.compact(list);

	// figure out which are directories
	var dirs = list.map(function(filename){
		return fs.statSync(Path.resolve(src, filename)).isDirectory();
	});	
		console.log(dirs);


	var fileIndex = 0;
	processNextFile();

	function processNextFile(){
		var filepath = Path.resolve(src, list[fileIndex]);


		if (dirs[fileIndex]){
			console.log(">>".red, filepath);
			return processFolder(filepath, size, function(){
				if (++fileIndex < list.length){
					processNextFile();
				} else {
					console.log("\n=====\n".cyan, "Directory Complete", filepath, "\n=====\n".green);
					cb();
				}
			});
		} else {
			var newScale = size/options.baseSize;
			console.log(((100*newScale) + "%").green, filepath);

			// HANDLE JPGs
			if (filepath.indexOf(".jpg") > -1){
				var resizer = spawn("convert", [filepath, "-resize", (100*newScale) + "%", filepath ])
				.then(function(){
					if (++fileIndex < list.length){
						processNextFile();
					} else {
						console.log("\n=====".green, "\ncj Directory Complete", filepath, "\n=====\n".green);
						cb();
					}
				});
				return resizer;

			// HANDLE PNGs
			} else if (filepath.indexOf(".png") > -1){
				var resizer = spawn("convert", [filepath, "-resize", (100*newScale) + "%", filepath ])
					.then(function(){
						console.log(("quantize").green,filepath);

						var quantizer = spawn("pngquant", ["--ext", ".png", "--force", 128, filepath]);

						return quantizer.then(function(){
							if (++fileIndex < list.length){
								processNextFile();
							} else {
								console.log("\n=====".green, "\nq Directory Complete", filepath, "\n=====\n".green);
								cb();
							}
						}).fail(function(){
							console.log("Process failed on ",filepath);
						});
					})
					.then(function(){
						if (++fileIndex < list.length){
							processNextFile();
						} else {
							console.log("\n=====".green, "\ncv Directory Complete", filepath, "\n=====\n".green);
							cb();
						}
					});
				return resizer;
			// HANDLE JSONs
			} else if (filepath.indexOf(".json") > -1){
				console.log(("update filmstrip json").green);

				return FS.read(filepath)
					.then(function(jsonString){
						var jsonObj = JSON.parse(jsonString);
						_.each(jsonObj.frames, function(frameObj, frameName){
							frameObj.frame.x = Math.round(frameObj.frame.x * newScale);
							frameObj.frame.y = Math.round(frameObj.frame.y * newScale);
							frameObj.frame.w = Math.round(frameObj.frame.w * newScale);
							frameObj.frame.h = Math.round(frameObj.frame.h * newScale);
							frameObj.spriteSourceSize.w = Math.round(frameObj.spriteSourceSize.w * newScale);
							frameObj.spriteSourceSize.h = Math.round(frameObj.spriteSourceSize.h * newScale);
							frameObj.sourceSize.w = Math.round(frameObj.sourceSize.w * newScale);
							frameObj.sourceSize.h = Math.round(frameObj.sourceSize.h * newScale);
						});
						jsonObj.meta.size.w = Math.round(jsonObj.meta.size.w * newScale);
						jsonObj.meta.size.h = Math.round(jsonObj.meta.size.h * newScale);
						return jsonObj;
					})
					.then(function(jsonObj){
						return FS.write(filepath, JSON.stringify(jsonObj));
					})
					.then(function(jsonObj){
						console.log(("update filmstrip json complete").greenBg, filepath);
					})
					.then(function(){
						if (++fileIndex < list.length){
							processNextFile();
						} else {
							console.log("\n=====".green, "\njs Directory Complete", filepath, "\n=====\n".green);
							cb();
						}
					})
					.fail(function(){
						console.log("updating filmstrip json failed".red, filepath);
					});
			}
				
		}

	}

	return deferred.promise;
}