var Q		= require("q");
var Qfs		= require("q-io/fs"); // may want to do some synchronous operations
var fs      = require("fs");
var Path	= require("path");
var yargs	= require("yargs");
var _		= require("underscore");
var colors	= require("colors");
var spawn   = require("child-process-promise").spawn;
var pkg		= require("./package.json");

var processFolder = require("./process-folder");

var options = yargs
    .usage('Process images into multiple sizes\n\nUsage: $0 -i <src folder> [options]')
    .help('help').alias('help', 'h')
    .version(pkg.version, 'version').alias('version', 'V')
    .options({
        src: {
            alias: 'i',
            description: "<folder> source images location",
            requiresArg: true,
            required: true
        },
        dest:{
        	alias: 'o',
            description: "<folder> processed images location",
            requiresArg: true,
            default: "../images_sized",
            required: false
        },
        sizes:{
        	alias: 's',
            description: "<array> JSON list of sizes to process",
            requiresArg: true,
            default: "[512,720,960,1024,1280,1440,1920]",
            required: false
        },
        baseSize: {
            alias: 'b',
            description: "<integer> standard size of source images",
            default: "1920",
            requiresArg: true,
            required: false
        },
    })
    .argv;


var startTime = Date.now();
var root = Path.resolve(options.src);
var dest = Path.resolve(root, options.dest);
var sizes = JSON.parse(options.sizes);
var baseSize = parseInt(options.baseSize);
process.chdir(root);

function cleanupFolderList(list){
	list = _.chain(list)
		.map(function(folderName){
			return fs.statSync(Path.join(root, folderName)).isDirectory() ? folderName : null;
		})
		.compact()
		.value();

	return list;
}

// --------------------------------------------
// Do it

// nuke dest folder
// copy src dirs
// for each sized folder
	// process folder
		// for each folder
			//process folder (recurse)
		// for each file
			// process file


return Qfs.makeTree(dest)
	.then(function(){
		// removeTree fails if it doesn't exist
		// so, make it then remove it then make it
		return Qfs.removeTree(dest);
	})
	.then(function(){
		return Qfs.makeTree(dest);
	})
	.then(function(){
		var functions = _.map(sizes, function(size){
			return function(){
				var sizePath = Path.join(dest, size.toString());
				console.log("making", sizePath);
				return Qfs.makeTree(sizePath);
			};
		});

		return _.reduce(functions, Q.when, Q());
	})
	.then(function(){
		var functions = _.map(sizes, function(size){
			return function(){
				var sizePath = Path.join(dest, size.toString());
				console.log("copying to", sizePath);
				return spawn("cp", ["-r",root + "/", sizePath]);
			};
		});

		return _.reduce(functions, Q.when, Q());
	})
	.then(function(){
		var functions = _.map(sizes, function(size){
			return function(){
				var sizePath = Path.join(dest, size.toString());
				console.log("processing", sizePath);
				return processFolder(sizePath, size);
			};
		});

		return _.reduce(functions, Q.when, Q());
	})
	.then(function(){
		console.log("Process Completed Successfully".green);
		console.log("  Duration", Math.round((Date.now() - startTime) / 100)/10, "seconds");
		process.exit();
	})
	.fail(function(e){
		console.log("Process Failed".red);
		console.log("  Duration", Math.round((Date.now() - startTime) / 100)/10, "seconds");
		console.log("  Error: ", e);
	});


