var _ = require("underscore");
var FS = require("fs");

var options = require("yargs")
	.option("r", {
		alias: "rotate",
		demand: false,
		describe: "Rotate projectors 90deg",
		type: "boolean",
		default: false
	})
	.argv;

var nodeStartIndex = 0;
var nodeStartX = 0;
var nodeStartY = 0;
var projectorStartIndex = 0;

var nodeOffset = 3;

var roomWidth = 95;
var roomHeight = 15;
var nodeSize = 1.5;
var projectionWidth = 15;
var projectionHeight = 7.5;

var nonOffsetProjectorIDs = [0, 7];

if (options.r) {
	var holder = projectionWidth;
	projectionWidth = projectionHeight;
	projectionHeight = holder;
}


// make a grid of nodes sufficient to cover the entire room
// use percentages to define nodes x&y
var nodes = [];
var numRows = Math.floor(roomHeight / nodeSize);
var numCols = Math.floor(roomWidth / nodeSize);

for (var rowIndex = 0; rowIndex < numRows; rowIndex++) {
	for (var colIndex = 0; colIndex < numCols; colIndex++) {
		nodes.push({
			"col": colIndex,
			"row": rowIndex,
			"x": colIndex * nodeSize / roomWidth,
			"y": rowIndex * nodeSize / roomHeight,
			"offsetX": 0,
			"offsetY": 0,
			"radius": 1,
			"active": false,
			"id": (rowIndex * numCols) + colIndex,
			"transmitId": (rowIndex * numCols) + colIndex,
			"masks": [

			]
		});
	}
}


// split nodes into projector grids
// projectors can cover limited nodes
var projectors = [];
var projectionNodeCoverageWidth = projectionWidth / nodeSize;
var projectionNodeCoverageHeight = projectionHeight / nodeSize;
var numProjectorsX = Math.ceil(roomWidth / projectionWidth);
var numProjectorsY = Math.ceil(roomHeight / projectionHeight);


for (var currentProjectorX = 0; currentProjectorX < numProjectorsX; currentProjectorX++) {
	for (var currentProjectorY = 0; currentProjectorY < numProjectorsY; currentProjectorY++) {

		var currentProjectorId = currentProjectorY * numProjectorsX + currentProjectorX;
		var firstCol = currentProjectorX * projectionNodeCoverageWidth;
		var firstRow = currentProjectorY * projectionNodeCoverageHeight;

		// TODO add extra coverage height to row 1 col 1-7
		var numProjectorRows = projectionNodeCoverageHeight;
		if (currentProjectorX > 0) {
			if (currentProjectorY === 1) {
				numProjectorRows += 2;
				firstRow -= 3;
			} else if (currentProjectorY === 0) {
				numProjectorRows -= 3;
			}
		}

		var projectorNodes = _.chain(nodes)
			.filter(function(node) {
				return node.col >= firstCol &&
					node.col < firstCol + projectionNodeCoverageWidth &&
					node.row >= firstRow &&
					node.row < firstRow + numProjectorRows;
			})
			.tap((nodes) => console.log(nodes.length))
			.each(function(node) {
				node.projectorId = currentProjectorId;
				node.active = (currentProjectorX === 0) || (node.row >= 2 && node.row < 7);
				return node;
			})
			.value();



		if (projectorNodes.length) {
			projectors.push({
				"col": firstCol,
				"row": firstRow,
				"numCols": projectionNodeCoverageWidth,
				"numRows": numProjectorRows,
				"id": currentProjectorId,
				"nodeIds": _.pluck(projectorNodes, "id"),
				"active": (currentProjectorX === 0 || currentProjectorY === 1),
				"align": "bottom",
				"rotation": 0
			});
		}

	}
}

console.log("Nodes Processed");

var projectorIds = _.pluck(projectors, "id");

var projectorCounts = _.map(projectorIds, (id) => {
	return {
		id: id,
		count: _.keys(_.where(nodes, {
			id: id
		})[0]).length
	};
});


console.log(projectorCounts);

// write json nodes
var output = {
	nodes: nodes,
	projectors: projectors,
	meta: {
		roomWidth: roomWidth,
		roomHeight: roomHeight,
		numRows: numRows,
		numCols: numCols,
		projectorWidth: projectionWidth / roomWidth,
		projectorHeight: projectionHeight / roomHeight,
		projectorRows: projectionNodeCoverageHeight,
		projectorCols: projectionNodeCoverageWidth
	}
};

FS.writeFileSync("./nodeData.json", JSON.stringify(output, null, "\t"));

console.log("File Written");
